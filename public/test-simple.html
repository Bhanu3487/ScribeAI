<!DOCTYPE html>
<html>
<head>
  <title>ScribeAI Test</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 50px auto;
      padding: 20px;
    }
    button {
      padding: 15px 30px;
      font-size: 18px;
      margin: 10px 0;
      cursor: pointer;
      border: none;
      border-radius: 5px;
    }
    #record {
      background-color: #4CAF50;
      color: white;
    }
    #record:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    #record.recording {
      background-color: #f44336;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    #status {
      margin: 20px 0;
      padding: 15px;
      background-color: #f0f0f0;
      border-radius: 5px;
      min-height: 50px;
    }
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #4CAF50;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .success { color: #4CAF50; }
    .error { color: #f44336; }
  </style>
</head>
<body>
  <h1>üéôÔ∏è ScribeAI Recording Test</h1>
  <button id="record">üî¥ Start Recording</button>
  <div id="status">Ready - Click to start recording</div>
  <div id="transcriptionSlot" style="margin-top:12px; padding:12px; background:#fff; border-left:4px solid #4CAF50; min-height:48px; font-size:16px;">.</div>
  <div id="statusLine" style="margin-top:8px; color:#666; font-size:13px">Idle</div>

  <script>
    let recorders = [null, null];
    let sessionId;
    let userId;
    let sequence = 0;
    let chunkMs = 5000;
    let isRecording = false;
    let lastSequence = -1;

    const recordBtn = document.getElementById('record');
    const statusDiv = document.getElementById('status');
    const transcriptionSlot = document.getElementById('transcriptionSlot');
    const statusLine = document.getElementById('statusLine');

    // Helper to wait for session completion
    async function waitForSessionCompletion(sessionId, maxWaitSeconds = 30) {
      const startTime = Date.now();
      const pollInterval = 2000; // Check every 2 seconds
      
      while (Date.now() - startTime < maxWaitSeconds * 1000) {
        try {
          const response = await fetch(`http://localhost:3000/api/session/summary?sessionId=${sessionId}`);
          const data = await response.json();
          
          console.log('Session status:', data);
          
          // Check if completed with summary
          if (data.status === 'COMPLETED' && data.hasSummary && data.hasFullTranscript) {
            return {
              success: true,
              summary: data.summary,
              fullTranscript: data.fullTranscript,
            };
          }
          
          // Check if still processing
          if (data.transcribingChunks > 0) {
            statusDiv.innerHTML = `‚è≥ Processing... ${data.transcribingChunks} chunks remaining <span class="spinner"></span>`;
          } else {
            statusDiv.innerHTML = `‚è≥ Generating summary... <span class="spinner"></span>`;
          }
          
          // Wait before next check
          await new Promise(resolve => setTimeout(resolve, pollInterval));
          
        } catch (err) {
          console.error('Error checking status:', err);
          await new Promise(resolve => setTimeout(resolve, pollInterval));
        }
      }
      
      return { success: false, error: 'Timeout waiting for completion' };
    }

    recordBtn.onclick = async () => {
      if (isRecording) {
        // ===== STOP RECORDING =====
        isRecording = false;
        statusDiv.innerHTML = 'üõë Stopping recording...';
        recordBtn.classList.remove('recording');
        recordBtn.textContent = 'üî¥ Start Recording';
        recordBtn.disabled = true;

        const finalSequence = lastSequence;

        // Stop all timers and recorders
        try {
          if (recordBtn._intervalHandle) {
            clearInterval(recordBtn._intervalHandle);
            recordBtn._intervalHandle = null;
          }
          if (recordBtn._stopTimers) {
            recordBtn._stopTimers.forEach((t) => t && clearTimeout(t));
            recordBtn._stopTimers = null;
          }

          for (let i = 0; i < recorders.length; i++) {
            const r = recorders[i];
            if (r && r.state === 'recording') {
              try { r.stop(); } catch (e) { console.warn('Error stopping recorder', i, e); }
            }
          }
        } catch (err) {
          console.warn('Error while stopping recorders:', err);
        }

        // Notify server to stop session
        try {
          statusDiv.innerHTML = 'üì§ Notifying server... <span class="spinner"></span>';
          
          const stopRes = await fetch('http://localhost:3000/api/session/stop', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ sessionId, lastSequence: finalSequence })
          });

          if (!stopRes.ok) {
            throw new Error('Failed to stop session');
          }

          const stopData = await stopRes.json();
          console.log('‚úì Session stopped:', stopData);

          // Wait for completion (backend will auto-generate summary)
          statusDiv.innerHTML = '‚è≥ Processing transcriptions and generating summary... <span class="spinner"></span>';
          
          const result = await waitForSessionCompletion(sessionId);
          
          if (result.success) {
            // Display results
            statusDiv.innerHTML = `
              <div class="success">‚úì Recording completed and processed!</div>
              <br>
              <strong>üìù AI Summary:</strong><br>
              <div style="font-size:14px; margin-top:10px; padding:10px; background:white; border-left:4px solid #2196F3;">
                ${result.summary.replace(/\n/g, '<br>')}
              </div>
              <br>
              <strong>üìÑ Full Transcript:</strong><br>
              <div style="font-size:13px; margin-top:10px; padding:10px; background:#f9f9f9; border-left:4px solid #9E9E9E; max-height:200px; overflow-y:auto;">
                ${result.fullTranscript}
              </div>
            `;
            transcriptionSlot.textContent = '‚úì Session completed';
            statusLine.textContent = 'Ready for new recording';
          } else {
            statusDiv.innerHTML = `<div class="error">‚ùå ${result.error}</div>`;
            statusLine.textContent = 'Error - please try again';
          }

        } catch (err) {
          console.error('Error during stop:', err);
          statusDiv.innerHTML = `<div class="error">‚ùå Error: ${err.message}</div>`;
          statusLine.textContent = 'Error occurred';
        }

        recordBtn.disabled = false;
        recorders = [null, null];
        sessionId = null;
        sequence = 0;
        lastSequence = -1;
        return;
      }

      // ===== START RECORDING =====
      try {
        recordBtn.disabled = true;
        statusDiv.textContent = 'üîß Setting up...';

        // Create user
        const userRes = await fetch('http://localhost:3000/api/auth/mock-login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email: 'test@scribeai.com' })
        });
        if (!userRes.ok) throw new Error('Failed to create user');
        const userData = await userRes.json();
        userId = userData.userId;

        // Create session
        const sessionRes = await fetch('http://localhost:3000/api/session/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId })
        });
        if (!sessionRes.ok) throw new Error('Failed to start session');
        const sessionData = await sessionRes.json();
        sessionId = sessionData.sessionId;

        // Get microphone
        statusDiv.textContent = 'üé§ Requesting microphone access...';
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
          ? 'audio/webm;codecs=opus'
          : (MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : '');

        function makeRecorder(idx) {
          const r = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);

          r.ondataavailable = async (event) => {
            if (!event.data || event.data.size === 0) return;
            const chunkBlob = event.data;
            const currentSeq = sequence++;
            lastSequence = currentSeq;

            statusLine.textContent = `üì§ Uploading chunk ${currentSeq}...`;

            const formData = new FormData();
            const ext = chunkBlob.type && chunkBlob.type.includes('webm') ? 'webm' : 'wav';
            formData.append('audio', chunkBlob, `chunk-${currentSeq}.${ext}`);
            formData.append('sessionId', sessionId);
            formData.append('sequence', String(currentSeq));

            try {
              const uploadRes = await fetch('http://localhost:3000/api/transcribe', {
                method: 'POST',
                body: formData
              });

              if (!uploadRes.ok) {
                statusLine.textContent = `‚ùå Chunk ${currentSeq} failed`;
                return;
              }

              const result = await uploadRes.json();
              transcriptionSlot.textContent = result.transcription || '.';
              statusLine.textContent = `‚úì Chunk ${currentSeq} transcribed`;
            } catch (err) {
              console.error('Error uploading chunk:', err);
              statusLine.textContent = `‚ùå Chunk ${currentSeq} error`;
            }
          };

          r.onstart = () => {
            recordBtn.classList.add('recording');
            recordBtn.textContent = '‚è∫Ô∏è Recording (click to stop)';
            statusDiv.textContent = `üéôÔ∏è Recording in progress...`;
            recordBtn.disabled = false;
          };

          return r;
        }

        recorders[0] = makeRecorder(0);
        recorders[1] = makeRecorder(1);

        const overlapMs = 800;
        const staggerMs = Math.max(100, chunkMs - overlapMs);
        recordBtn._stopTimers = [null, null];

        function startRecorderOnce(idx) {
          try {
            if (!recorders[idx]) recorders[idx] = makeRecorder(idx);
            recorders[idx].start();
          } catch (e) {
            console.error('Failed to start recorder', idx, e);
            return;
          }

          if (recordBtn._stopTimers[idx]) clearTimeout(recordBtn._stopTimers[idx]);
          recordBtn._stopTimers[idx] = setTimeout(() => {
            try {
              if (recorders[idx] && recorders[idx].state === 'recording') {
                recorders[idx].stop();
              }
            } catch (err) {
              console.warn('Error stopping recorder', idx, err);
            }
            recordBtn._stopTimers[idx] = null;
          }, chunkMs);
        }

        (function beginOverlapLoop() {
          isRecording = true;
          startRecorderOnce(0);
          recordBtn._intervalHandle = setInterval(() => {
            const nextIdx = (Date.now() / staggerMs) % 2 < 1 ? 1 : 0;
            startRecorderOnce(nextIdx);
          }, staggerMs);
        })();

        recordBtn.disabled = false;
      } catch (error) {
        console.error('Error starting recording:', error);
        statusDiv.innerHTML = `<div class="error">‚ùå Error: ${error.message}</div>`;
        recordBtn.disabled = false;
      }
    };
  </script>
</body>
</html>